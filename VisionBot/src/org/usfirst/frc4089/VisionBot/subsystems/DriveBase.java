// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc4089.VisionBot.subsystems;

import org.usfirst.frc4089.VisionBot.RobotMap;
import org.usfirst.frc4089.VisionBot.commands.*;
import edu.wpi.first.wpilibj.command.Subsystem;

import com.ctre.phoenix.motorcontrol.ControlMode;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.sensors.PigeonIMU;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.Joystick;
import stealth_libraries.StealthMath;

import org.usfirst.frc4089.VisionBot.*;
import stealth_libraries.StopWatch;

/**
 *
 */
public class DriveBase extends Subsystem {

  // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

  // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

  // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

  // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

  double kPgain = 0.03; /* percent throttle per degree of error */
  double kDgain = 0.0004; /* percent throttle per angular velocity dps */
  double kMaxCorrectionRatio = 0.20; /* cap corrective turning throttle to 30 percent of forward throttle */
  double mTargetAngle = 0;
  boolean mJoystick = true;
   
  private StopWatch debugDisplay = new StopWatch(200);

  @Override
  public void initDefaultCommand() {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

    setDefaultCommand(new UserDrive());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
  }

  @Override
  public void periodic() {
  }

  public void SetJoystick(boolean joystick)
  {
    mJoystick = joystick;
  }

  public void SetTargetAngle(double targetAngle)
  {
    mTargetAngle = targetAngle;
  }
  
  public void Drive(Joystick driveJoystick) {
    double y = driveJoystick.getRawAxis(1)*-1;
    double x = driveJoystick.getRawAxis(0)*-1;

    // Adjust for speed, check if the fast button is pushed
    if (true == driveJoystick.getRawButton(Constants.kFastButton)) {
      // Do Nothing
    } else {
      // Is the slow button pushed
      if (true == driveJoystick.getRawButton(Constants.kSlowButton)) {
        y *= Constants.kSlowSpeed;
        x *= Constants.kSlowSpeed;
      } else {
        y *= Constants.kNormalSpeed;
        x *= Constants.kNormalSpeed;
      }
    }
    if(true == mJoystick)
    {
      Drive(y, x);
    }
  }

  public void Drive(double forward, double turn) {
    PigeonIMU.FusionStatus fusionStatus = new PigeonIMU.FusionStatus();
    double [] xyz_dps = new double [3];
    RobotMap.pigeonIMU.getRawGyro(xyz_dps);
    RobotMap.pigeonIMU.getFusedHeading(fusionStatus);
    
    double currentAngle = fusionStatus.heading;
    double currentAngularRate = xyz_dps[2];
    double turnThrottle = turn;
    
    // IF we are turning, turn off the gyro
    if (Math.abs(turn) > 0.2) {
      RawDrive(forward/1.3, turn/1.3);
      mTargetAngle = currentAngle;
    } else {
      if (Math.abs(forward) > 0.1) {
        double angleError = (mTargetAngle - currentAngle);
        /* very simple Proportional and Derivative (PD) loop with a cap,
         * replace with favorite close loop strategy or leverage future Talon <=> Pigeon features. */
        turnThrottle = angleError * kPgain - (currentAngularRate) * kDgain;
        /* the max correction is the forward throttle times a scalar,
         * This can be done a number of ways but basically only apply small turning correction when we are moving slow
         * and larger correction the faster we move.  Otherwise you may need stiffer pgain at higher velocities. */
        double maxThrot = StealthMath.MaxCorrection(forward, kMaxCorrectionRatio);
        turnThrottle =  StealthMath.Cap(turnThrottle, maxThrot);
        
        RobotMap.netTable.putNumber("gyroRate", currentAngularRate);
        RobotMap.netTable.putNumber("angleError", angleError);
        RobotMap.netTable.putNumber("turnAdj", turnThrottle);
        
        RawDrive(forward,turnThrottle);
      }
      else
      {
        RawDrive(0, 0);
        mTargetAngle = currentAngle;
      }
      
      
      System.out.format("AR:%7.2f TR:%7.2f %7.2f %7.2f %7.2f ", 
          currentAngularRate,
          mTargetAngle,
          currentAngle, 
          turnThrottle,
          forward);
        

      
    }
  }

  protected void RawDrive(double forward, double turn) {
    double targetSpeedL = (forward - turn) * 4096 * .8;
    double targetSpeedR = (forward + turn) * 4096 * .8;
    RobotMap.leftMotor1SpeedCpmtroler.set(ControlMode.Velocity, targetSpeedL);
    RobotMap.rightMotor1SpeedCpmtroler.set(ControlMode.Velocity, targetSpeedR);

    RobotMap.netTable.putNumber("lMotor", RobotMap.leftMotor1SpeedCpmtroler.getMotorOutputVoltage());
    RobotMap.netTable.putNumber("rMotor", RobotMap.rightMotor1SpeedCpmtroler.getMotorOutputVoltage());
    RobotMap.netTable.putNumber("lEncoder", RobotMap.leftEncoder.GetInches());
    RobotMap.netTable.putNumber("rEncoder", RobotMap.rightEncoder.GetInches());

    Navigation.getInstance().setNewPose(RobotMap.leftEncoder.GetInches(), RobotMap.rightEncoder.GetInches());

    System.out.format("RE:%7.2f LE:%7.2f %7.2f %7.2f %7.2f %7.2f %7.2f\n", RobotMap.leftEncoder.GetInches(),
        RobotMap.rightEncoder.GetInches(), RobotMap.leftEncoder.GetVelocityInInches(),
        RobotMap.rightEncoder.GetVelocityInInches(), Navigation.getInstance().getX()/12.0, 
        Navigation.getInstance().getY()/12.0,
        Navigation.getInstance().getThetaDeg());
  }

  public void ClearEncoders() {
    RobotMap.leftEncoder.Clear();
    RobotMap.rightEncoder.Clear();
  }
}
