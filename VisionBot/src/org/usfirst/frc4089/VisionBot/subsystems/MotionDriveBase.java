//----------------------------------------------------------------------------
//
//  $Workfile: DriveBase.java$
//
//  $Revision: X$
//
//  Project:    Stealth Libraries
//
//                            Copyright (c) 2018
//                               Cedarcrest High School
//                            All Rights Reserved
//
//  Modification History:
//  $Log:
//  $
//
//----------------------------------------------------------------------------
package org.usfirst.frc4089.VisionBot.subsystems;

import org.usfirst.frc4089.VisionBot.RobotMap;
import org.usfirst.frc4089.VisionBot.commands.*;
import edu.wpi.first.wpilibj.command.Subsystem;

import com.ctre.phoenix.motion.MotionProfileStatus;
import com.ctre.phoenix.motion.SetValueMotionProfile;
import com.ctre.phoenix.motion.TrajectoryPoint;
import com.ctre.phoenix.motion.TrajectoryPoint.TrajectoryDuration;
import com.ctre.phoenix.ErrorCode;
import com.ctre.phoenix.motorcontrol.ControlMode;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.sensors.PigeonIMU;

import edu.wpi.first.wpilibj.DriverStation;
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.Notifier;
import stealth_libraries.StealthMath;

import org.usfirst.frc4089.VisionBot.*;
import stealth_libraries.StopWatch;

//----------------------------------------------------------------------------
//Class Declarations
//----------------------------------------------------------------------------
//
//Class Name: DriveBase
//
//Purpose:
//  Handle getting us from here to there
//
//----------------------------------------------------------------------------
public class MotionDriveBase {

  /**
   * How many trajectory points do we wait for before firing the motion
   * profile.
   */
  private static final int kMinPointsInTalon = 5;
  /**
   * Just a state timeout to make sure we don't get stuck anywhere. Each loop
   * is about 20ms.
   */
  private static final int kNumLoopsTimeout = 1000;  
  
  private MotionProfileStatus mMotionStatusLeft = new MotionProfileStatus();
  private MotionProfileStatus mMotionStatusRight = new MotionProfileStatus();
  
  class PeriodicRunnable implements java.lang.Runnable {
    public void run() {  
      RobotMap.leftMotor1SpeedControler.processMotionProfileBuffer();
      RobotMap.rightMotor1SpeedControler.processMotionProfileBuffer();
  }
  }
  Notifier mNotifer = new Notifier(new PeriodicRunnable());

  
  
  //--------------------------------------------------------------------
  // Purpose:
  //     Init the command
  //
  // Notes:
  //     None.
  //--------------------------------------------------------------------   
  public void initPaths(double[][] leftPath, double[][] rightPath) {
    int numberOfPoints = leftPath.length;
    
    /* create an empty point */
    TrajectoryPoint leftPoint = new TrajectoryPoint();
    TrajectoryPoint rightPoint = new TrajectoryPoint();

    leftPoint.headingDeg = 0; /* future feature - not used in this example*/
    leftPoint.profileSlotSelect0 = 0; /* which set of gains would you like to use [0,3]? */
    leftPoint.profileSlotSelect1 = 0; /* future feature  - not used in this example - cascaded PID [0,1], leave zero */

    rightPoint.headingDeg = 0; /* future feature - not used in this example*/
    rightPoint.profileSlotSelect0 = 0; /* which set of gains would you like to use [0,3]? */
    rightPoint.profileSlotSelect1 = 0; /* future feature  - not used in this example - cascaded PID [0,1], leave zero */
    
    /*
     * just in case we are interrupting another MP and there is still buffer
     * points in memory, clear it.
     */
    
    RobotMap.leftMotor1SpeedControler.clearMotionProfileTrajectories();
    RobotMap.rightMotor1SpeedControler.clearMotionProfileTrajectories();

    /* set the base trajectory period to zero, use the individual trajectory period below */
    RobotMap.leftMotor1SpeedControler.configMotionProfileTrajectoryPeriod(
        Constants.kBaseTrajPeriodMs, Constants.kTimeoutMs);
    RobotMap.leftMotor1SpeedControler.configMotionProfileTrajectoryPeriod(
        Constants.kBaseTrajPeriodMs, Constants.kTimeoutMs);
    
    /* This is fast since it's just into our TOP buffer */
    for (int i = 0; i < numberOfPoints; ++i) {
      /* for each point, fill our structure and pass it to API */
      leftPoint.position = leftPath[i][0]*Constants.kTicksPerRev; //Convert Revolutions to Units
      leftPoint.velocity = leftPath[i][1]*Constants.kTicksPErRevSpeeed; //Convert RPM to Units/100ms
      leftPoint.timeDur = GetTrajectoryDuration(20);
      leftPoint.zeroPos = false;
      if (i == 0)
      {
        leftPoint.zeroPos = true; /* set this to true on the first point */
      }
      
      leftPoint.isLastPoint = false;
      if ((i + 1) == numberOfPoints)
      {
        leftPoint.isLastPoint = true; /* set this to true on the last point  */
      }
      
      ErrorCode errorCode = RobotMap.leftMotor1SpeedControler.pushMotionProfileTrajectory(leftPoint);
      /*
      System.out.format("%d %f %b %f %d %d %d %f %b ",i,
          leftPoint.headingDeg,
          leftPoint.isLastPoint,
          leftPoint.position,
          leftPoint.profileSlotSelect0,
          leftPoint.profileSlotSelect1,
          leftPoint.timeDur.value,
          leftPoint.velocity,
          leftPoint.zeroPos);
      System.out.println("Error:"+i+" "+errorCode);
      */
      
      /* for each point, fill our structure and pass it to API */
      rightPoint.position = rightPath[i][0]*Constants.kTicksPerRev; //Convert Revolutions to Units
      rightPoint.velocity = rightPath[i][1]*Constants.kTicksPErRevSpeeed; //Convert RPM to Units/100ms
      rightPoint.timeDur = GetTrajectoryDuration(20);
      rightPoint.zeroPos = false;
      if (i == 0)
      {
        rightPoint.zeroPos = true; /* set this to true on the first point */
      }
      
      rightPoint.isLastPoint = false;
      if ((i + 1) == numberOfPoints)
      {
        rightPoint.isLastPoint = true; /* set this to true on the last point  */
      }
      
      RobotMap.rightMotor1SpeedControler.pushMotionProfileTrajectory(rightPoint);
    }
    
    ErrorCode errorCode = RobotMap.leftMotor1SpeedControler.getMotionProfileStatus(mMotionStatusLeft);
    System.out.println("Errorz:"+errorCode);
    System.out.println("stat:"+mMotionStatusLeft.activePointValid);
    mNotifer.startPeriodic(0.005);
  }

  /**
   * Find enum value if supported.
   * @param durationMs
   * @return enum equivalent of durationMs
   */
  private TrajectoryDuration GetTrajectoryDuration(int durationMs)
  {  
    /* create return value */
    TrajectoryDuration retval = TrajectoryDuration.Trajectory_Duration_0ms;
    /* convert duration to supported type */
    retval = retval.valueOf(durationMs);
    /* check that it is valid */
    if (retval.value != durationMs) {
      DriverStation.reportError("Trajectory Duration not supported - use configMotionProfileTrajectoryPeriod instead", false);    
    }
    /* pass to caller */
    return retval;
  }
 
  //--------------------------------------------------------------------
  // Purpose:
  //     Calls from every tick
  //
  // Notes:
  //     None.
  //--------------------------------------------------------------------  
  public void periodic() {
    MotionProfileStatus _status = new MotionProfileStatus();
    double _pos=0,_vel=0,_heading=0;
    
    
    RobotMap.leftMotor1SpeedControler.set(
        ControlMode.MotionProfile, SetValueMotionProfile.Enable.value);
    
    RobotMap.rightMotor1SpeedControler.set(
        ControlMode.MotionProfile, SetValueMotionProfile.Enable.value);    
    
  }

  //--------------------------------------------------------------------
  // Purpose:
  //     Calls from every tick
  //
  // Notes:
  //     None.
  //--------------------------------------------------------------------  
  public void stop() {
  
    mNotifer.stop();
    
    RobotMap.leftMotor1SpeedControler.set(
        ControlMode.MotionProfile, SetValueMotionProfile.Disable.value);
    RobotMap.rightMotor1SpeedControler.set(
        ControlMode.MotionProfile, SetValueMotionProfile.Disable.value);
  }
  
  //--------------------------------------------------------------------
  // Purpose:
  //     Calls from every tick
  //
  // Notes:
  //     None.
  //--------------------------------------------------------------------  
  public boolean isDone() {
    
    RobotMap.leftMotor1SpeedControler.getMotionProfileStatus(mMotionStatusLeft);
    RobotMap.rightMotor1SpeedControler.getMotionProfileStatus(mMotionStatusRight);
     
    System.out.println(mMotionStatusLeft.isLast);
    if((true == mMotionStatusLeft.isLast)||
        (true == mMotionStatusRight.isLast))
    {
      //System.out.println("End");
      return true;
    }
    
    return false;
  }
  
  
}
